#lang sicp

(define (all-combinations lists)
  (cond ((null? lists) nil)
        ((null? (cdr lists)) (map list (car lists)))
        (else (let ((rest-combinations (all-combinations (cdr lists))))
                (apply append
                       (map (lambda (x)
                              (map (lambda (c) (cons x c)) rest-combinations))
                            (car lists)))))))

(define (repeating item count)
  (if (= count 0)
      nil
      (cons item (repeating item (- count 1)))))

(define (distinct? items)
  (cond ((null? items) true)
        ((null? (cdr items)) true)
        ((member (car items) (cdr items)) false)
        (else (distinct? (cdr items)))))

(define (multiple-dwelling)
  (let* ((floors (list 1 2 3 4 5))
         (count 5))
    (define (iter combinations)
      (if (null? combinations)
          nil
          (let* ((combination (car combinations))
                 (baker    (car combination))
                 (cooper   (cadr combination))
                 (fletcher (caddr combination))
                 (miller   (cadddr combination))
                 (smith    (car (cddddr combination))))
            (if (and (distinct? (list baker cooper fletcher miller smith))
                     (not (= baker 5))
                     (not (= cooper 1))
                     (not (= fletcher 5))
                     (not (= fletcher 1))
                     (> miller cooper)
                     (not (= (abs (- smith fletcher)) 1))
                     (not (= (abs (- fletcher cooper)) 1)))
                (list (list 'baker baker)
                      (list 'cooper cooper)
                      (list 'fletcher fletcher)
                      (list 'miller miller)
                      (list 'smith smith))
                (iter (cdr combinations))))))
    (iter (all-combinations (repeating floors count)))))

(define (numeric-iterator low high)
  (let ((current low))
    (lambda (dispatch)
      (cond ((eq? dispatch 'current) (list current))
            ((eq? dispatch 'end?)
             (= high current))
            ((eq? dispatch 'next)
             (set! current (+ current 1)))
            ((eq? dispatch 'reset)
             (set! current low))))))

(define (iter-current iterator)
  (iterator 'current))

(define (iter-next iterator)
  (if (iter-end? iterator)
      (error "End of iterator")
      (iterator 'next))
  iterator)

(define (iter-end? iterator)
  (iterator 'end?))

(define (iter-reset iterator)
  (iterator 'reset)
  iterator)

(define (combine-iterators iterators)
  (cond ((null? iterators) (error "No iterators given"))
        ((null? (cdr iterators)) (car iterators))
        (else (let ((left (car iterators))
                    (right (combine-iterators (cdr iterators))))
                (lambda (dispatch)
                  (cond ((eq? dispatch 'current)
                         (append (iter-current left)
                                 (iter-current right)))
                        ((eq? dispatch 'end?)
                         (and (iter-end? left) (iter-end? right)))
                        ((eq? dispatch 'next)
                         (if (iter-end? right)
                             (begin (iter-reset right) (iter-next left))
                             (iter-next right)))
                        ((eq? dispatch 'reset)
                         (iter-reset right)
                         (iter-reset left))))))))

(define (call f)
  (f))

(define (multiple-dwelling-2)
  (let* ((generators (repeating (lambda () (numeric-iterator 1 5)) 5))
         (iterator (combine-iterators (map call generators))))
    (define (loop)
      (if (iter-end? iterator)
          nil
          (let* ((combination (iter-current iterator))
                 (baker    (car combination))
                 (cooper   (cadr combination))
                 (fletcher (caddr combination))
                 (miller   (cadddr combination))
                 (smith    (car (cddddr combination))))
            (if (and (distinct? (list baker cooper fletcher miller smith))
                     (not (= baker 5))
                     (not (= cooper 1))
                     (not (= fletcher 5))
                     (not (= fletcher 1))
                     (> miller cooper)
                     (not (= (abs (- smith fletcher)) 1))
                     (not (= (abs (- fletcher cooper)) 1)))
                (list (list 'baker baker)
                      (list 'cooper cooper)
                      (list 'fletcher fletcher)
                      (list 'miller miller)
                      (list 'smith smith))
                (begin (iter-next iterator) (loop))))))
    (loop)))
                         
